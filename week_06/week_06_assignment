! pip install 'geopandas[all]'

%%bash
head -10 MO_pop_sim.csv

#The first column denotes if the residence is Urban or Rural
#The next two columns are longitude and latitude

import geopandas as gpd
import pandas as pd
from shapely.geometry import Point

# Read the shapefile
shapefile_path = "MO_2018_Federally_Qualified_Health_Center_Locations"
gdf = gpd.read_file(shapefile_path)

print(gdf.crs) # print the coordinate reference system
crs = gdf.crs
gdf = gdf.set_index("OBJECTID")

print(gdf.columns)
fqhc_df = gdf['geometry']
fqhc_df

print(gdf.head(5))

# Convert gdf to a projected CRS (e.g., UTM zone 15N, which covers parts of Missouri)
gdf_projected = gdf.to_crs(epsg=26915)

# Convert 30 miles to meters (1 mile ≈ 1609.34 meters)
buffer_distance_meters = 30 * 1609.34

# Create the buffer (a true 30-mile radius in meters) in the projected CRS
circles_geom_projected = gdf_projected.buffer(buffer_distance_meters)

# Create a new GeoDataFrame with these buffered geometries in the projected CRS
fqhc_circles_df_projected = gpd.GeoDataFrame(gdf_projected, geometry=circles_geom_projected, crs=gdf_projected.crs)


fqhc_circles_df = fqhc_circles_df_projected.to_crs(crs)
fqhc_circles_df

def create_point_column(df, lon_col, lat_col, crs="EPSG:4326"):
    """
    Creates a geometry column of Point objects from longitude and latitude columns in a DataFrame.

    Args:
        df (pandas.DataFrame): The DataFrame containing longitude and latitude columns.
        lon_col (str): The name of the longitude column.
        lat_col (str): The name of the latitude column.
        crs (str, optional): Coordinate Reference System. Defaults to "EPSG:4326".

    Returns:
        geopandas.GeoDataFrame: A GeoDataFrame with the added geometry column.
    """

    geometry = [Point(xy) for xy in zip(df[lon_col], df[lat_col])]
    gdf = gpd.GeoDataFrame(df, geometry=geometry, crs=crs)
    return gdf

# Read the shapefile
pop_file_path = "Mo_pop_Sim.csv"  # Replace with the actual path
big_pop_df = pd.read_csv(pop_file_path)
pop_df = big_pop_df.sample(frac=0.01) 

pop_gdf = create_point_column(pop_df, 'long', 'lat', crs)
pop_gdf

print(pop_gdf.columns)

len(pop_gdf)

pop_in_circles = gpd.sjoin(pop_gdf, fqhc_circles_df, predicate='within').groupby('OBJECTID').count()
pop_in_circles

# Re-project pop_gdf to the same projected CRS as your facility data (e.g., EPSG:26915)
pop_gdf_projected = pop_gdf.to_crs(epsg=26915)

# Now perform the nearest neighbor spatial join in the projected CRS.
# This finds, for each population point, the closest facility.
closest_fqhc_projected = gpd.sjoin_nearest(pop_gdf_projected, gdf_projected, how="left", distance_col="distance")

closest_fqhc = closest_fqhc_projected.to_crs(crs)
closest_fqhc


count = closest_fqhc.groupby('OBJECTID').count()
count

import random

# GA parameters
POPULATION_SIZE = 300    
NUM_GENERATIONS = 100   
NUM_FACILITIES = 8      
MUTATION_RATE = 0.1     


all_facilities = list(gdf.index)

pop_counts = pop_in_circles['long']

def fitness(candidate):
    return sum(pop_counts.get(fac, 0) for fac in candidate)

def selection(population):
    fitness_values = [fitness(candidate) for candidate in population]
    total_fitness = sum(fitness_values)
    pick = random.uniform(0, total_fitness)
    current = 0
    for candidate, fit in zip(population, fitness_values):
        current += fit
        if current > pick:
            return candidate

def crossover(parent1, parent2):
    point = random.randint(1, NUM_FACILITIES - 1)
    child = parent1[:point] + [fac for fac in parent2 if fac not in parent1[:point]]
    while len(child) < NUM_FACILITIES:
        candidate = random.choice(all_facilities)
        if candidate not in child:
            child.append(candidate)
    return child[:NUM_FACILITIES]

def mutate(candidate):
    if random.random() < MUTATION_RATE:
        index_to_replace = random.randint(0, NUM_FACILITIES - 1)
        new_facility = random.choice(all_facilities)
        while new_facility in candidate:
            new_facility = random.choice(all_facilities)
        candidate[index_to_replace] = new_facility
    return candidate

# Initialize the population with random candidates
population = [random.sample(all_facilities, NUM_FACILITIES) for _ in range(POPULATION_SIZE)]
best_candidate = None
best_fitness = 0

# Create a list to record best fitness at each generation
best_fitness_history = []

# Main GA Loop
for generation in range(NUM_GENERATIONS):
    new_population = []
    for _ in range(POPULATION_SIZE):
        parent1 = selection(population)
        parent2 = selection(population)
        child = crossover(parent1, parent2)
        child = mutate(child)
        new_population.append(child)
        child_fit = fitness(child)
        if child_fit > best_fitness:
            best_fitness = child_fit
            best_candidate = child
    population = new_population
    best_fitness_history.append(best_fitness)
    print(f"Generation {generation}, Best Fitness: {best_fitness}")

print("Optimal set of FQHCs:", best_candidate)
print("Total population served:", best_fitness)


import matplotlib.pyplot as plt

# Plot: Best Fitness Over Generations
plt.figure(figsize=(10, 6))
plt.plot(best_fitness_history, marker='o', linestyle='-')
plt.title("Best Fitness per Generation")
plt.xlabel("Generation")
plt.ylabel("Best Fitness (Population Served)")
plt.grid(True)
plt.show()

# Plot: Population Served by Each Selected Facility
pop_served = [pop_counts.get(fac, 0) for fac in best_candidate]

plt.figure(figsize=(10, 6))
plt.bar([str(fac) for fac in best_candidate], pop_served)
plt.title("Population Served by Each Selected Facility")
plt.xlabel("Facility ID")
plt.ylabel("Population Served")
plt.show()


In evaluating the relative suitability of potential locations, we considered two primary methods:

1. Average Distance to Residences  
   This approach involves calculating the average distance from each location to all residences. A location with a lower average distance is more centrally positioned and, theoretically, more accessible. The assumption is that reducing the average travel distance increases accessibility and service utilization.

2. Number of Residences Within a 30-Mile Radius (Density)  
   This method counts the number of residences located within 30 miles of each location. A higher count suggests that the facility could serve a larger population. The underlying assumption is that residents within this radius are more likely to use the facility, making locations with a higher density of nearby residences more favorable.

### Selected Approach

I chose the number of residences within a 30-mile radius as the primary criterion. This decision aims to maximize the total number of people served by the new specialized mental health services. From a public health perspective, it is generally more beneficial to select locations that provide the greatest coverage, even if it results in slightly longer travel distances for some residents.

### Assumptions

1. 30-Mile Service Radius  
   It is assumed that 30 miles represents a reasonable distance for individuals to travel for mental health services.

2. Equal Accessibility  
   All residents within the 30-mile radius are considered equally served, without adjustments for factors such as urban versus rural differences or transportation challenges.

3. Overlapping Coverage  
   When evaluating individual locations, potential overlap with other facilities is not considered. If selecting multiple locations in the future, a decision will be made on whether to count overlapping residents once (unique coverage) or multiple times (summed coverage). For the current evaluation, the focus is on each location’s ability to serve residents within its 30-mile range independently.

### Fitness Measure

The suitability of a location is determined by the number of residents within 30 miles. The objective is to maximize this value, meaning a location with a greater number of residents within its 30-mile radius is considered more favorable.

In cases where multiple facilities are selected, the total count can either be summed across facilities (allowing for potential double-counting) or adjusted to reflect the unique number of residents served within the combined service areas. The primary goal remains to maximize coverage and accessibility.

